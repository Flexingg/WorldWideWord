WordWideWeb ðŸŒðŸ“–
> An offline-first, high-performance Bible Reader PWA built on the Adapter Pattern.
> 
Live Demo: https://flexingg.github.io/WordWideWeb/
ðŸš€ Overview
WordWideWeb is a serverless Single Page Application (SPA) designed for deep Bible study. It utilizes a "Static API" architecture, where the content (Bible chapters, Lexicon definitions, and Audio) consists of standard static files hosted on GitHub Pages.
The application uses Client-Side Rendering (CSR) to parse Markdown into a rich, interactive UI. It features a custom Adapter Layer (js/adapter.js) that abstracts platform differences, allowing the core logic to run seamlessly as a web app (using fetch and localStorage) or embedded within Android automation tools like Tasker.
âœ¨ Key Features
 * Offline-First PWA: Installs to home screen; uses a Service Worker to cache content and assets for offline use.
 * Static Data Source: No database required. Content is served from raw Markdown files.
 * Virtual Audio Timeline: Stitches multiple audio clips into a seamless playback experience with a custom waveform scrubber.
 * Persistent User Data: Highlights, notes, and reading history are stored locally in the browser.
 * Smart Search: Client-side search engine powered by a pre-generated JSON index.
 * Material 3 Design: Fully responsive UI with dark/light mode and expressive animations.
 * Lexicon Integration: Instant definitions for Strong's numbers (e.g., [[H1234]]).
ðŸ—ï¸ Architecture
The codebase follows a modular separation of concerns:
1. The Adapter Pattern (js/adapter.js)
This is the core abstraction layer. It exposes a unified API (AppAPI.readFile, AppAPI.saveData, AppAPI.speak) that automatically detects the runtime environment.
 * Web Mode: Uses fetch() for content, localStorage for user data, and the Web Speech API/HTML5 Audio.
 * Hybrid Mode (Tasker): Can detect Android injection interfaces to delegate storage and TTS to the host operating system.
2. The Logic Layer (js/app.js)
Contains the State Management and UI Controllers.
 * Selector: Handles book navigation, search, and history.
 * Reader: Handles Markdown parsing, rendering, verse selection, and highlighting.
 * ReaderAudio: Manages the HTML5 Audio object, playlist queuing, and UI synchronization.
3. The Data Layer (Static Files)
The "backend" is simply a structured file system.
 * bibles/: Contains Markdown files for chapters (e.g., BER-Genesis/Genesis 1.md).
 * lexicon/: Contains Markdown files for definitions (e.g., H1.md).
 * data/: Contains generated indexes (search_index.json).
ðŸ“‚ Directory Structure
/ (root)
â”œâ”€â”€ index.html            # Main entry point (SPA shell)
â”œâ”€â”€ manifest.json         # PWA configuration
â”œâ”€â”€ sw.js                 # Service Worker (Offline caching logic)
â”œâ”€â”€ generate_index.py     # Python script to build search index
â”‚
â”œâ”€â”€ css/
â”‚   â””â”€â”€ style.css         # Material 3 Styles & Variables
â”‚
â”œâ”€â”€ js/
â”‚   â”œâ”€â”€ app.js            # Core Application Logic
â”‚   â””â”€â”€ adapter.js        # Platform Abstraction Layer
â”‚
â”œâ”€â”€ data/
â”‚   â””â”€â”€ search_index.json # Generated by python script (required for search)
â”‚
â”œâ”€â”€ lexicon/              # Strong's Definitions
â”‚   â”œâ”€â”€ H1.md
â”‚   â””â”€â”€ ...
â”‚
â””â”€â”€ bibles/               # Bible Translations
    â””â”€â”€ BSB/
        â”œâ”€â”€ BER-Genesis/
        â”‚   â”œâ”€â”€ Genesis 1.md
        â”‚   â””â”€â”€ ...
        â””â”€â”€ ...

ðŸ› ï¸ Setup & Deployment
1. Content Management
To add or update Bible text:
 * Place standard Markdown files in bibles/{Translation}/BER-{Book}/{Chapter}.md.
 * Ensure verses follow the header format ###### VerseNumber.
 * Ensure Strong's tags use the format [[H1234]].
2. Audio Management
Audio is handled via "Chunking" to bypass browser buffer limits and support static hosting.
 * Place MP3 files in: bibles/{Translation}/BER-{Book}/Audio/{ChapterName}/.
 * Name files sequentially: part_0.mp3, part_1.mp3, etc.
 * The app automatically chains these files into a virtual timeline.
3. Generating the Search Index
Since the app has no backend database, search is performed using a pre-computed index. You must run this script whenever you add new text files.
# From the repository root
python3 generate_index.py

This generates data/search_index.json, a compressed map of every verse in the library.
4. Hosting
This repository is configured for GitHub Pages.
 * Push your changes to the main branch.
 * Go to Settings > Pages.
 * Select main as the source.
 * Your site will be live at https://flexingg.github.io/WordWideWeb/.
ðŸ”® Future Extensibility
 * Parallel Views: The CSS Grid layout (#contentArea) supports multiple columns. To implement parallel reading, fetch two markdown files via AppAPI.readFile and render them into side-by-side divs.
 * Cloud Sync: adapter.js can be extended to support a RemoteStorage provider (like Firebase or Google Drive API) to sync the JSON data currently stored in localStorage.
 * Multiple Translations: The path logic in Selector.openBook currently hardcodes BSB. This can be dynamic based on a global setting.
Â© 2025 WordWideWeb Project. Open Source.
